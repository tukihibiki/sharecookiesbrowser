# Copyright (C) 2025 [hibiki-YE]
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations
import asyncio
from datetime import datetime, timedelta
import json
import logging
import re
from typing import Dict, List, Optional, Any
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Request, Header
from fastapi.responses import JSONResponse
from pathlib import Path
import uvicorn
from playwright.async_api import async_playwright, Browser, Page, BrowserContext
import uuid
import os
import secrets
import hashlib
import psutil
import configparser
from logging.handlers import RotatingFileHandler

# Êó•ÂøóÈÖçÁΩÆ
log_dir = Path("logs")
log_dir.mkdir(exist_ok=True)
log_file = log_dir / "remote_browser_server.log"
handler = RotatingFileHandler(log_file, maxBytes=5*1024*1024, backupCount=3, encoding='utf-8')
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[handler, logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# --- ÂÖ®Â±ÄÁä∂ÊÄÅÁÆ°ÁêÜ ---
class AppState:
    server_state: ServerState
    access_coordinator: AccessCoordinator
    connection_manager: ConnectionManager
    admin_browser_task: Optional[asyncio.Task] = None
    cookie_update_task: Optional[asyncio.Task] = None

app = FastAPI(title="Remote Browser Server")
app.state = AppState()

class ConnectionManager:
    """ÁÆ°ÁêÜWebSocketËøûÊé•"""
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.client_info: Dict[str, Dict] = {}  # Â≠òÂÇ®ÂÆ¢Êà∑Á´ØËØ¶ÁªÜ‰ø°ÊÅØ

    async def connect(self, websocket: WebSocket, session_id: str):
        await websocket.accept()
        self.active_connections[session_id] = websocket
        
        # ËÆ∞ÂΩïÂÆ¢Êà∑Á´Ø‰ø°ÊÅØ
        client_ip = self._get_client_ip(websocket)
        self.client_info[session_id] = {
            "ip_address": client_ip,
            "connect_time": datetime.now(),
            "websocket": websocket
        }
        
        logger.info(f"ÂÆ¢Êà∑Á´Ø‰ºöËØù {session_id[:8]} Â∑≤ËøûÊé• (IP: {client_ip})")

    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]
        if session_id in self.client_info:
            del self.client_info[session_id]
        logger.info(f"ÂÆ¢Êà∑Á´Ø‰ºöËØù {session_id[:8]} Â∑≤Êñ≠ÂºÄ")
    
    def _get_client_ip(self, websocket: WebSocket) -> str:
        """Ëé∑ÂèñÂÆ¢Êà∑Á´ØIPÂú∞ÂùÄ"""
        try:
            # ‰ºòÂÖàÊ£ÄÊü•X-Forwarded-ForÂ§¥Ôºà‰ª£ÁêÜÊúçÂä°Âô®Ôºâ
            headers = dict(websocket.headers)
            forwarded_for = headers.get('x-forwarded-for')
            if forwarded_for:
                # ÂèñÁ¨¨‰∏Ä‰∏™IPÔºàÁúüÂÆûÂÆ¢Êà∑Á´ØIPÔºâ
                return forwarded_for.split(',')[0].strip()
            
            # Ê£ÄÊü•X-Real-IPÂ§¥
            real_ip = headers.get('x-real-ip')
            if real_ip:
                return real_ip
            
            # Ëé∑ÂèñÁõ¥ËøûIP
            if hasattr(websocket, 'client') and websocket.client:
                return websocket.client.host
            
            return "unknown"
        except Exception as e:
            logger.warning(f"Ëé∑ÂèñÂÆ¢Êà∑Á´ØIPÂ§±Ë¥•: {e}")
            return "unknown"
    
    def get_client_info(self, session_id: str) -> Dict:
        """Ëé∑ÂèñÂÆ¢Êà∑Á´Ø‰ø°ÊÅØ"""
        return self.client_info.get(session_id, {})

    async def send_personal_message(self, message: str, session_id: str):
        if session_id in self.active_connections:
            websocket = self.active_connections[session_id]
            await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections.values():
            await connection.send_text(message)

class AccessCoordinator:
    """ËÆøÈóÆÂçèË∞ÉÂô® - ÂÆûÁé∞ÂÆ¢Êà∑Á´ØÊéíÈòüÂíåÂπ∂ÂèëÊéßÂà∂"""
    def __init__(self, connection_manager: ConnectionManager, server_state: ServerState):
        self.access_lock = asyncio.Lock()
        self.active_clients: Dict[str, Dict] = {}
        self.waiting_queue: List[Dict] = []
        self.monitoring_task: Optional[asyncio.Task] = None
        self.connection_manager = connection_manager
        self.server_state = server_state
        self.load_config()

    def load_config(self):
        """Âä†ËΩΩÈÖçÁΩÆ"""
        config_section = self.server_state.server_config['server'] if self.server_state.server_config.has_section('server') else None
        
        if config_section:
            self.max_concurrent_clients = config_section.getint('max_concurrent_clients', 2)
            self.heartbeat_interval = config_section.getint('heartbeat_interval', 30)
            self.max_inactive_minutes = config_section.getint('max_inactive_minutes', 10)
        else:
            # Â¶ÇÊûúÈÖçÁΩÆÈÉ®ÂàÜ‰∏çÂ≠òÂú®Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº
            self.max_concurrent_clients = 2
            self.heartbeat_interval = 30
            self.max_inactive_minutes = 10
            
        logger.info(f"ËÆøÈóÆÂçèË∞ÉÂô®ÈÖçÁΩÆÂä†ËΩΩ: max_concurrent_clients={self.max_concurrent_clients}")

    async def start_monitoring(self):
        if self.monitoring_task is None:
            self.monitoring_task = asyncio.create_task(self._monitor_active_client())
            logger.info("üì° ÂºÄÂßãÁõëÊéßÊ¥ªË∑ÉÂÆ¢Êà∑Á´ØÁä∂ÊÄÅ")

    async def stop_monitoring(self):
        if self.monitoring_task:
            self.monitoring_task.cancel()
            self.monitoring_task = None
            logger.info("üì° ÂÅúÊ≠¢ÁõëÊéßÊ¥ªË∑ÉÂÆ¢Êà∑Á´ØÁä∂ÊÄÅ")

    async def request_access(self, client_id: str, priority: int = 0, requested_domains: List[str] = None) -> Dict[str, Any]:
        async with self.access_lock:
            current_time = datetime.now()

            if not requested_domains:
                return await self._traditional_access_request(client_id, priority, current_time)

            logger.info(f"üåê ÂÆ¢Êà∑Á´Ø {client_id[:8]} ËØ∑Ê±ÇÂüüÂêç: {requested_domains}")
            allocation_check = self.server_state.can_allocate_domains(client_id, requested_domains)

            if client_id in self.active_clients and set(requested_domains) == set(self.active_clients[client_id].get("allocated_domains", [])):
                self.active_clients[client_id]["last_activity"] = current_time
                return {"granted": True, "status": "already_active_with_same_domains", "message": "ÊÇ®Â∑≤ÁªèÊòØÊ¥ªË∑ÉÂÆ¢Êà∑Á´ØÔºåÂüüÂêçÂ∑≤ÂàÜÈÖç", "allocated_domains": requested_domains}

            is_in_queue = any(item['client_id'] == client_id for item in self.waiting_queue)

            if is_in_queue and (not allocation_check['can_allocate'] or len(self.active_clients) >= self.max_concurrent_clients):
                return await self._queue_for_domain_access(client_id, priority, current_time, requested_domains, allocation_check)

            if allocation_check['can_allocate'] and len(self.active_clients) < self.max_concurrent_clients:
                if is_in_queue:
                    self.waiting_queue = [item for item in self.waiting_queue if item['client_id'] != client_id]
                
                self.active_clients[client_id] = {"start_time": current_time, "last_activity": current_time, "allocated_domains": requested_domains}
                self.server_state.allocate_domains_to_client(client_id, requested_domains)
                return {"granted": True, "status": "direct_grant_with_domains", "message": "ËÆøÈóÆÊùÉÈôêÂíåÂüüÂêçÂ∑≤ÂàÜÈÖç", "allocated_domains": requested_domains}

            return await self._queue_for_domain_access(client_id, priority, current_time, requested_domains, allocation_check)

    async def _traditional_access_request(self, client_id: str, priority: int, current_time: datetime) -> Dict[str, Any]:
        if client_id in self.active_clients:
            self.active_clients[client_id]["last_activity"] = current_time
            return {"granted": True, "status": "already_active", "message": "ÊÇ®Â∑≤ÁªèÊòØÂΩìÂâçÊ¥ªË∑ÉÂÆ¢Êà∑Á´Ø"}

        if len(self.active_clients) < self.max_concurrent_clients:
            self.active_clients[client_id] = {"start_time": current_time, "last_activity": current_time}
            return {"granted": True, "status": "direct_grant", "message": "ËÆøÈóÆÊùÉÈôêÂ∑≤ÂàÜÈÖç"}
        
        return await self._add_to_queue(client_id, priority, current_time)

    async def _queue_for_domain_access(self, client_id: str, priority: int, current_time: datetime, requested_domains: List[str], allocation_check: Dict) -> Dict[str, Any]:
        # ... (queueing logic as corrected before)
        position = self._get_client_position(client_id)
        if not any(item['client_id'] == client_id for item in self.waiting_queue):
             self.waiting_queue.append({"client_id": client_id, "request_time": current_time, "priority": priority, "requested_domains": requested_domains})
             # sort queue by priority
             self.waiting_queue.sort(key=lambda x: x['priority'], reverse=True)
             position = self._get_client_position(client_id)

        if not allocation_check['can_allocate'] and allocation_check.get('unavailable_domains'):
            first_unavailable = allocation_check['unavailable_domains'][0]
            reason = f"ÂüüÂêç'{first_unavailable['domain']}'‰∏çÂèØÁî®({first_unavailable['reason']})"
        elif allocation_check['conflicts']:
            reason = "ÂüüÂêçÂ∑≤Ë¢´Âç†Áî®"
        else:
            reason = "ÊúçÂä°Âô®Êª°ËΩΩ"
        
        return {"granted": False, "status": "queued_for_domains", "message": f"Â∑≤Âä†ÂÖ•Á≠âÂæÖÈòüÂàóÔºåÂΩìÂâç‰ΩçÁΩÆÔºö{position}ÔºåÂéüÂõ†Ôºö{reason}", "position": position}

    async def _add_to_queue(self, client_id: str, priority: int, current_time: datetime) -> Dict[str, Any]:
        # ... (queueing logic as corrected before)
        position = self._get_client_position(client_id)
        if not any(item['client_id'] == client_id for item in self.waiting_queue):
             self.waiting_queue.append({"client_id": client_id, "request_time": current_time, "priority": priority})
             self.waiting_queue.sort(key=lambda x: x['priority'], reverse=True)
             position = self._get_client_position(client_id)

        return {"granted": False, "status": "queued", "message": f"Â∑≤Âä†ÂÖ•Á≠âÂæÖÈòüÂàóÔºåÂΩìÂâç‰ΩçÁΩÆÔºö{position}", "position": position}
    
    def _get_client_position(self, client_id: str) -> int:
        for i, item in enumerate(self.waiting_queue):
            if item["client_id"] == client_id:
                return i + 1
        return 0

    async def release_access(self, client_id: str, reason: str = "manual_release"):
        async with self.access_lock:
            if client_id in self.active_clients:
                del self.active_clients[client_id]
                self.server_state.release_domains_from_client(client_id)
                logger.info(f"üîì ÂÆ¢Êà∑Á´Ø {client_id[:8]} ÈáäÊîæËÆøÈóÆÊùÉÈôêÔºàÂéüÂõ†Ôºö{reason}Ôºâ")
                await self._assign_next_client()

    async def _assign_next_client(self):
        if self.waiting_queue:
            next_in_line = self.waiting_queue.pop(0)
            client_id = next_in_line['client_id']
            # Simplified grant logic for brevity
            await self._grant_access_to_client(next_in_line, next_in_line.get("requested_domains", []))

    async def _grant_access_to_client(self, queue_item: Dict, domains: List[str]):
        client_id = queue_item['client_id']
        self.active_clients[client_id] = {"start_time": datetime.now(), "last_activity": datetime.now(), "allocated_domains": domains}
        if domains:
            self.server_state.allocate_domains_to_client(client_id, domains)
        
        notification = {"type": "access_granted", "message": "ÊÇ®ÁöÑËÆøÈóÆÊùÉÈôêÂ∑≤Ëé∑ÂæóÊâπÂáÜ", "allocated_domains": domains}
        await self.connection_manager.send_personal_message(json.dumps(notification), client_id)
        
    async def _monitor_active_client(self):
        while True:
            await asyncio.sleep(60)
            async with self.access_lock:
                current_time = datetime.now()
                timed_out_clients = []
                for client_id, info in self.active_clients.items():
                    if (current_time - info["last_activity"]).total_seconds() > self.max_inactive_minutes * 60:
                        timed_out_clients.append(client_id)
                
                for client_id in timed_out_clients:
                    logger.warning(f"‚è∞ ÂÆ¢Êà∑Á´Ø {client_id[:8]} Ë∂ÖÊó∂Êú™ÂìçÂ∫îÔºåËá™Âä®ÈáäÊîæ")
                    await self.release_access(client_id, "timeout")

    async def update_activity(self, client_id: str) -> bool:
        async with self.access_lock:
            if client_id in self.active_clients:
                self.active_clients[client_id]["last_activity"] = datetime.now()
                return True
            return False

    async def cleanup_stale_clients(self):
        async with self.access_lock:
            self.active_clients.clear()
            self.waiting_queue.clear()
            self.server_state.domain_allocations.clear()
            logger.info("üßπ Â∑≤Ê∏ÖÁêÜÊâÄÊúâÈôàÊóßÁöÑÂÆ¢Êà∑Á´Ø‰ºöËØùÂíåÈòüÂàó")

    async def get_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñËÆøÈóÆÂçèË∞ÉÂô®Áä∂ÊÄÅ"""
        async with self.access_lock:
            active_client = None
            active_client_info = {}
            
            if self.active_clients:
                active_client = list(self.active_clients.keys())[0]
                client_info = self.active_clients[active_client]
                current_time = datetime.now()
                usage_time = (current_time - client_info["start_time"]).total_seconds() / 60
                inactive_time = (current_time - client_info["last_activity"]).total_seconds() / 60
                
                active_client_info = {
                    "usage_minutes": round(usage_time, 1),
                    "inactive_minutes": round(inactive_time, 1)
                }
            
            queue_details = []
            for i, item in enumerate(self.waiting_queue):
                current_time = datetime.now()
                wait_time = (current_time - item["request_time"]).total_seconds() / 60
                
                queue_details.append({
                    "position": i + 1,
                    "client_id": item["client_id"],
                    "priority": item.get("priority", 0),
                    "wait_minutes": round(wait_time, 1),
                    "requested_domains": item.get("requested_domains", [])
                })
            
            return {
                "active_client": active_client,
                "active_client_info": active_client_info,
                "active_count": len(self.active_clients),
                "max_concurrent": self.max_concurrent_clients,
                "queue_length": len(self.waiting_queue),
                "queue_details": queue_details
            }

    async def remove_from_queue(self, client_id: str) -> Dict[str, Any]:
        """‰ªéÁ≠âÂæÖÈòüÂàó‰∏≠ÁßªÈô§ÂÆ¢Êà∑Á´Ø"""
        async with self.access_lock:
            old_length = len(self.waiting_queue)
            self.waiting_queue = [item for item in self.waiting_queue if item["client_id"] != client_id]
            new_length = len(self.waiting_queue)
            
            return {
                "removed": old_length - new_length > 0,
                "old_queue_length": old_length,
                "new_queue_length": new_length
            }

    def set_max_concurrent_clients(self, max_clients: int):
        """ËÆæÁΩÆÊúÄÂ§ßÂπ∂ÂèëÂÆ¢Êà∑Á´ØÊï∞Âπ∂‰øùÂ≠òÂà∞ÈÖçÁΩÆÊñá‰ª∂"""
        self.max_concurrent_clients = max_clients
        
        # Êõ¥Êñ∞ÈÖçÁΩÆÊñá‰ª∂
        if not self.server_state.server_config.has_section('server'):
            self.server_state.server_config.add_section('server')
        
        self.server_state.server_config.set('server', 'max_concurrent_clients', str(max_clients))
        
        try:
            with self.server_state.config_file.open('w', encoding='utf-8') as f:
                self.server_state.server_config.write(f)
            logger.info(f"ÊúÄÂ§ßÂπ∂ÂèëÂÆ¢Êà∑Á´ØÊï∞Â∑≤Êõ¥Êñ∞‰∏∫ {max_clients} Âπ∂‰øùÂ≠òÂà∞ÈÖçÁΩÆÊñá‰ª∂")
        except Exception as e:
            logger.error(f"‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂Â§±Ë¥•: {e}")

# ... (ServerState class remains largely the same, methods are fine)
class ServerState:
    def __init__(self):
        self.config_file = Path("server_config.ini")
        self.server_config = configparser.ConfigParser() # ÂàùÂßãÂåñ‰∏∫Á©∫ÁöÑConfigParser
        self._load_server_config() # Âä†ËΩΩÈÖçÁΩÆ
        self.global_cookies: List[Dict] = []
        self.available_domains: Dict[str, int] = {}
        self.domain_allocations: Dict[str, str] = {} # {domain: client_id}
        self.sessions: Dict[str, Dict] = {}
        self.is_logged_in = False
        self.cookies_last_updated = None  # Ê∑ªÂä†cookiesÊúÄÂêéÊõ¥Êñ∞Êó∂Èó¥
        
        # ÁÆ°ÁêÜÂëòÊµèËßàÂô®Áõ∏ÂÖ≥
        self.playwright = None
        self.admin_browser = None  
        self.admin_context = None
        self.admin_page = None
        self.admin_key = self._load_or_create_admin_key()

    def _load_server_config(self):
        """Âä†ËΩΩÊàñÂàõÂª∫ÊúçÂä°Âô®ÈÖçÁΩÆÊñá‰ª∂"""
        try:
            if self.config_file.exists():
                self.server_config.read(self.config_file, encoding='utf-8')
            else:
                # Â¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆ
                self.server_config['server'] = {
                    'max_concurrent_clients': '2',
                    'heartbeat_interval': '30',
                    'max_inactive_minutes': '10'
                }
                with self.config_file.open('w', encoding='utf-8') as f:
                    self.server_config.write(f)
                logger.info(f"Â∑≤ÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆÊñá‰ª∂: {self.config_file}")
        except Exception as e:
            logger.error(f"Âä†ËΩΩÊàñÂàõÂª∫ÈÖçÁΩÆÊñá‰ª∂Â§±Ë¥•: {e}")
            # Âç≥‰ΩøÂä†ËΩΩÂ§±Ë¥•Ôºå‰πüÊèê‰æõ‰∏Ä‰∏™ÈªòËÆ§ÁöÑ 'server' section
            if not self.server_config.has_section('server'):
                self.server_config.add_section('server')

    def can_allocate_domains(self, client_id: str, requested_domains: List[str]) -> Dict[str, Any]:
        conflicts = []
        unavailable = []
        can_allocate = True
        for domain in requested_domains:
            if domain in self.domain_allocations and self.domain_allocations[domain] != client_id:
                conflicts.append(domain)
                can_allocate = False
            if domain not in self.available_domains:
                unavailable.append({"domain": domain, "reason": "domain_not_exists"})
                can_allocate = False
        return {"can_allocate": can_allocate, "conflicts": conflicts, "unavailable_domains": unavailable, "available_domains": list(self.available_domains.keys())}
    
    def allocate_domains_to_client(self, client_id: str, domains: List[str]):
        for domain in domains:
            self.domain_allocations[domain] = client_id

    def release_domains_from_client(self, client_id: str):
        released = []
        for domain, owner_id in list(self.domain_allocations.items()):
            if owner_id == client_id:
                del self.domain_allocations[domain]
                released.append(domain)
        return released
    
    async def load_cookies_from_disk(self):
        """‰ªéÁ£ÅÁõòÂä†ËΩΩcookies"""
        try:
            cookies_dir = Path("browser_data")
            main_cookies_file = cookies_dir / "shared_cookies.json"
            
            if main_cookies_file.exists():
                with main_cookies_file.open('r', encoding='utf-8') as f:
                    cookies_data = json.load(f)
                
                self.global_cookies = cookies_data.get('cookies', [])
                self.is_logged_in = cookies_data.get('logged_in', False)
                
                # Ëß£ÊûêÊó∂Èó¥Êà≥
                last_updated_str = cookies_data.get('last_updated')
                if last_updated_str:
                    try:
                        self.cookies_last_updated = datetime.fromisoformat(last_updated_str)
                    except:
                        self.cookies_last_updated = None
                
                logger.info(f"‚úÖ ‰ªéÁ£ÅÁõòÂä†ËΩΩcookies: {len(self.global_cookies)}‰∏™")
                logger.info(f"   ÁôªÂΩïÁä∂ÊÄÅ: {self.is_logged_in}")
                logger.info(f"   ÊúÄÂêéÊõ¥Êñ∞: {self.cookies_last_updated}")
                
            else:
                # Â¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàõÂª∫Á©∫ÁöÑcookies
                self.global_cookies = []
                self.is_logged_in = False
                self.cookies_last_updated = None
                logger.info("üìÅ cookiesÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàùÂßãÂåñ‰∏∫Á©∫")
            
            self.update_available_domains()
            
        except Exception as e:
            logger.error(f"‰ªéÁ£ÅÁõòÂä†ËΩΩcookiesÂ§±Ë¥•: {e}")
            # Âá∫ÈîôÊó∂‰ΩøÁî®Á©∫ÁöÑcookies
            self.global_cookies = []
            self.is_logged_in = False
            self.cookies_last_updated = None
            self.update_available_domains()

    def update_available_domains(self):
        self.available_domains.clear()
        for cookie in self.global_cookies:
            domain = cookie.get("domain")
            if domain:
                # remove leading dot if exists
                if domain.startswith("."):
                    domain = domain[1:]
                self.available_domains[domain] = self.available_domains.get(domain, 0) + 1
        logger.info(f"Êõ¥Êñ∞ÂèØÁî®ÂüüÂêç: {len(self.available_domains)}‰∏™ÂüüÂêç")

    def _load_or_create_admin_key(self) -> str:
        """Âä†ËΩΩÊàñÂàõÂª∫ÁÆ°ÁêÜÂëòÂØÜÈí•"""
        try:
            key_file = Path("browser_data/admin_key.txt")
            key_file.parent.mkdir(exist_ok=True)
            
            if key_file.exists():
                admin_key = key_file.read_text(encoding='utf-8').strip()
            else:
                # ÁîüÊàêÊñ∞ÁöÑÁÆ°ÁêÜÂëòÂØÜÈí•
                admin_key = secrets.token_urlsafe(32)
                key_file.write_text(admin_key, encoding='utf-8')
                logger.info("Â∑≤ÁîüÊàêÊñ∞ÁöÑÁÆ°ÁêÜÂëòÂØÜÈí•")
            
            return admin_key
        except Exception as e:
            logger.error(f"ÁÆ°ÁêÜÂëòÂØÜÈí•Â§ÑÁêÜÂ§±Ë¥•: {e}")
            return "admin123"  # ÂõûÈÄÄÂà∞ÈªòËÆ§ÂØÜÈí•

    def verify_admin_key(self, key: str) -> bool:
        """È™åËØÅÁÆ°ÁêÜÂëòÂØÜÈí•"""
        return key == self.admin_key

    async def save_cookies_to_disk(self):
        """‰øùÂ≠òcookiesÂà∞Á£ÅÁõò"""
        try:
            cookies_dir = Path("browser_data")
            cookies_dir.mkdir(exist_ok=True)
            
            # ‰øùÂ≠ò‰∏ªË¶ÅcookiesÊñá‰ª∂
            main_cookies_file = cookies_dir / "shared_cookies.json"
            cookies_data = {
                "cookies": self.global_cookies,
                "logged_in": self.is_logged_in,
                "last_updated": self.cookies_last_updated.isoformat() if self.cookies_last_updated else None,
                "count": len(self.global_cookies),
                "available_domains": self.available_domains,
                "timestamp": datetime.now().isoformat()
            }
            
            with main_cookies_file.open('w', encoding='utf-8') as f:
                json.dump(cookies_data, f, ensure_ascii=False, indent=2)
            
            # ÊåâÂüüÂêçÂàÜÁªÑ‰øùÂ≠ò
            cookies_by_domain = {}
            for cookie in self.global_cookies:
                domain = cookie.get('domain', '').lstrip('.')
                if domain:
                    if domain not in cookies_by_domain:
                        cookies_by_domain[domain] = []
                    cookies_by_domain[domain].append(cookie)
            
            # ‰∏∫ÊØè‰∏™ÂüüÂêç‰øùÂ≠òÂçïÁã¨ÁöÑÊñá‰ª∂
            for domain, domain_cookies in cookies_by_domain.items():
                domain_safe = re.sub(r'[^\w\-_.]', '_', domain)
                domain_file = cookies_dir / f"{domain_safe}_cookies.json"
                
                domain_data = {
                    "domain": domain,
                    "cookies": domain_cookies,
                    "count": len(domain_cookies),
                    "timestamp": datetime.now().isoformat()
                }
                
                with domain_file.open('w', encoding='utf-8') as f:
                    json.dump(domain_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"‚úÖ ‰øùÂ≠ò {len(self.global_cookies)} ‰∏™cookiesÂà∞Á£ÅÁõò ({len(cookies_by_domain)} ‰∏™ÂüüÂêç)")
            
        except Exception as e:
            logger.error(f"‰øùÂ≠òcookiesÂ§±Ë¥•: {e}")


# --- ËæÖÂä©ÂáΩÊï∞ ---
async def init_admin_browser():
    """ÂàùÂßãÂåñÁÆ°ÁêÜÂëòÊµèËßàÂô® - ÁúüÂÆûPlaywrightÂÆûÁé∞"""
    try:
        server_state = app.state.server_state
        
        if not server_state.playwright:
            logger.info("Ê≠£Âú®ÂêØÂä®Playwright...")
            server_state.playwright = await async_playwright().start()

        if not server_state.admin_browser:
            logger.info("Ê≠£Âú®ÂêØÂä®ÁÆ°ÁêÜÂëòÊµèËßàÂô®...")
            server_state.admin_browser = await server_state.playwright.chromium.launch(
                headless=False,
                args=[
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-gpu',
                    '--no-first-run',
                    '--no-service-autorun',
                    '--no-default-browser-check',
                    '--password-store=basic',
                    '--start-maximized'
                ]
            )

        # ÂàõÂª∫ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñá - Áî®‰∫écookiesÁÆ°ÁêÜ
        if not server_state.admin_context:
            logger.info("Ê≠£Âú®ÂàõÂª∫ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñá...")
            server_state.admin_context = await server_state.admin_browser.new_context(
                no_viewport=True
            )
            
            # ÂàõÂª∫ÁÆ°ÁêÜÂëòÈ°µÈù¢
            server_state.admin_page = await server_state.admin_context.new_page()
            
            # ËÆæÁΩÆÈ°µÈù¢‰∫ã‰ª∂ÁõëÂê¨ - Ëá™Âä®Ê£ÄÊµãcookiesÂèòÂåñ
            server_state.admin_page.on("response", lambda response: asyncio.create_task(handle_admin_response(response)))
            
            logger.info("ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñáÂàõÂª∫ÊàêÂäü")
            
            # ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊµèËßàÂô®‰∏ä‰∏ãÊñáÂàõÂª∫ÂêéÔºåÁ´ãÂç≥Âä†ËΩΩ‰øùÂ≠òÁöÑcookies
            await load_saved_cookies_to_browser()

        logger.info("‚úÖ ÁÆ°ÁêÜÂëòÊµèËßàÂô®ÂàùÂßãÂåñÂÆåÊàê")
    except Exception as e:
        logger.error(f"ÁÆ°ÁêÜÂëòÊµèËßàÂô®ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
        raise

async def load_saved_cookies_to_browser():
    """Â∞Ü‰øùÂ≠òÁöÑcookiesÂä†ËΩΩÂà∞ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏≠"""
    try:
        server_state = app.state.server_state
        
        if not server_state.admin_context:
            logger.warning("ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñáÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÂä†ËΩΩcookies")
            return
            
        if not server_state.global_cookies:
            logger.info("Ê≤°Êúâ‰øùÂ≠òÁöÑcookiesÈúÄË¶ÅÂä†ËΩΩÂà∞ÊµèËßàÂô®")
            return
            
        logger.info(f"Ê≠£Âú®Â∞Ü {len(server_state.global_cookies)} ‰∏™‰øùÂ≠òÁöÑcookiesÂä†ËΩΩÂà∞ÁÆ°ÁêÜÂëòÊµèËßàÂô®...")
        
        # Â§ÑÁêÜcookiesÊ†ºÂºèÔºåÁ°Æ‰øù‰∏éPlaywrightÂÖºÂÆπ
        cookies_to_load = []
        for cookie in server_state.global_cookies:
            try:
                # Á°Æ‰øùcookieÊ†ºÂºèÊ≠£Á°Æ
                if cookie.get('name') and cookie.get('value'):
                    processed_cookie = {
                        'name': str(cookie['name']),
                        'value': str(cookie['value']),
                        'domain': cookie.get('domain', ''),
                        'path': cookie.get('path', '/'),
                        'secure': bool(cookie.get('secure', False)),
                        'httpOnly': bool(cookie.get('httpOnly', False)),
                        'sameSite': cookie.get('sameSite', 'Lax')
                    }
                    
                    # Â§ÑÁêÜexpires
                    if 'expires' in cookie and cookie['expires'] is not None:
                        try:
                            expires = float(cookie['expires'])
                            if expires > 0:
                                processed_cookie['expires'] = expires
                        except (ValueError, TypeError):
                            pass
                    
                    cookies_to_load.append(processed_cookie)
                    logger.debug(f"ÂáÜÂ§áÂä†ËΩΩcookie: {cookie['name']} (domain: {cookie.get('domain')})")
                    
            except Exception as e:
                logger.warning(f"Â§ÑÁêÜcookie {cookie.get('name', 'unknown')} Êó∂Âá∫Èîô: {e}")
        
        # Â∞ÜcookiesÊ∑ªÂä†Âà∞ÊµèËßàÂô®‰∏ä‰∏ãÊñá
        if cookies_to_load:
            await server_state.admin_context.add_cookies(cookies_to_load)
            logger.info(f"‚úÖ Â∑≤Â∞Ü {len(cookies_to_load)} ‰∏™cookiesÂä†ËΩΩÂà∞ÁÆ°ÁêÜÂëòÊµèËßàÂô®")
        else:
            logger.warning("‚ö†Ô∏è Ê≤°ÊúâÊúâÊïàÁöÑcookiesÂèØ‰ª•Âä†ËΩΩÂà∞ÊµèËßàÂô®")
            
    except Exception as e:
        logger.error(f"Âä†ËΩΩcookiesÂà∞ÊµèËßàÂô®Â§±Ë¥•: {e}")

async def handle_admin_response(response):
    """Â§ÑÁêÜÁÆ°ÁêÜÂëòÈ°µÈù¢ÂìçÂ∫îÔºåËá™Âä®Ê£ÄÊµãcookiesÂèòÂåñ"""
    try:
        # Âú®ÂÖ≥ÈîÆÂìçÂ∫îÂêéÊõ¥Êñ∞cookies
        critical_keywords = ['login', 'auth', 'session', 'token', 'signin', 'sso', 'oauth']
        if any(keyword in response.url.lower() for keyword in critical_keywords):
            logger.info(f"ÁÆ°ÁêÜÂëòÈ°µÈù¢Ê£ÄÊµãÂà∞ÂÖ≥ÈîÆÂìçÂ∫î: {response.url}")
            await asyncio.sleep(0.5)  # Á≠âÂæÖcookiesËÆæÁΩÆÂÆåÊàê
            await auto_update_cookies_from_admin()
            
    except Exception as e:
        logger.error(f"Â§ÑÁêÜÁÆ°ÁêÜÂëòÂìçÂ∫îÊó∂Âá∫Èîô: {e}")

async def auto_update_cookies_from_admin():
    """Ëá™Âä®‰ªéÁÆ°ÁêÜÂëòÊµèËßàÂô®Ëé∑ÂèñcookiesÂπ∂Êõ¥Êñ∞Âà∞ÊúçÂä°Âô® - ÊîπËøõÁâàÊú¨"""
    try:
        server_state = app.state.server_state
        
        if not server_state.admin_context:
            logger.warning("ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñá‰∏çÂ≠òÂú®ÔºåÊó†Ê≥ïËá™Âä®Êõ¥Êñ∞cookies")
            return
            
        logger.debug("ÂºÄÂßãËá™Âä®‰ªéÁÆ°ÁêÜÂëòÊµèËßàÂô®Ëé∑Âèñcookies...")
        
        # Ëé∑ÂèñÁÆ°ÁêÜÂëòÊµèËßàÂô®ÁöÑcookies
        cookies = await server_state.admin_context.cookies()
        
        # Ê†áÂáÜÂåñcookiesÊ†ºÂºè
        standardized_cookies = []
        for cookie in cookies:
            if cookie.get('name') and cookie.get('value'):
                standardized_cookie = {
                    'name': cookie['name'],
                    'value': cookie['value'],
                    'domain': cookie.get('domain', ''),
                    'path': cookie.get('path', '/'),
                    'secure': cookie.get('secure', False),
                    'httpOnly': cookie.get('httpOnly', False),
                    'sameSite': cookie.get('sameSite', 'Lax')
                }
                
                if 'expires' in cookie and cookie['expires'] != -1:
                    standardized_cookie['expires'] = cookie['expires']
                
                standardized_cookies.append(standardized_cookie)
        
        # Ê£ÄÊü•cookiesÊòØÂê¶ÊúâÂèòÂåñ
        if standardized_cookies != server_state.global_cookies:
            old_count = len(server_state.global_cookies)
            new_count = len(standardized_cookies)
            
            server_state.global_cookies = standardized_cookies
            server_state.cookies_last_updated = datetime.now()
            
            # Ê£ÄÊü•ÁôªÂΩïÁä∂ÊÄÅ
            await check_login_status()
            
            logger.info(f"üîÑ ÁÆ°ÁêÜÂëòËá™Âä®Êõ¥Êñ∞cookies: {old_count} ‚Üí {new_count} ‰∏™")
            
            # Êõ¥Êñ∞ÂèØÁî®ÂüüÂêç
            server_state.update_available_domains()
            
            # ‰øùÂ≠òÂà∞Á£ÅÁõò
            await server_state.save_cookies_to_disk()
            
            # ÈÄöÁü•ÊâÄÊúâÂÆ¢Êà∑Á´Ø
            await notify_clients_cookies_updated()
        else:
            logger.debug("cookiesÊó†ÂèòÂåñÔºåË∑≥ËøáÊõ¥Êñ∞")
                
    except Exception as e:
        logger.error(f"Ëá™Âä®Êõ¥Êñ∞cookiesÂ§±Ë¥•: {e}")

async def check_login_status():
    """Ê£ÄÊü•ÁôªÂΩïÁä∂ÊÄÅ"""
    try:
        server_state = app.state.server_state
        
        # Ê£ÄÊü•ÊòØÂê¶ÊúâËÆ§ËØÅÁõ∏ÂÖ≥ÁöÑcookies
        auth_cookies = ['sessionid', 'token', 'uid', 'sid', 'PHPSESSID', 'JSESSIONID', 'auth', 'login']
        has_auth_cookie = any(
            any(auth_keyword in cookie['name'].lower() for auth_keyword in auth_cookies)
            for cookie in server_state.global_cookies
        )
        
        # Ê£ÄÊü•ÂΩìÂâçÈ°µÈù¢URLÊòØÂê¶Ë°®ÊòéÂ∑≤ÁôªÂΩï
        is_on_login_page = False
        if server_state.admin_page:
            current_url = server_state.admin_page.url
            login_indicators = ['login', 'signin', 'auth', 'sso']
            is_on_login_page = any(indicator in current_url.lower() for indicator in login_indicators)
        
        # Âà§Êñ≠ÁôªÂΩïÁä∂ÊÄÅ
        was_logged_in = server_state.is_logged_in
        server_state.is_logged_in = has_auth_cookie and not is_on_login_page
        
        if server_state.is_logged_in and not was_logged_in:
            logger.info("Ê£ÄÊµãÂà∞ÁÆ°ÁêÜÂëòÂ∑≤ÁôªÂΩïÔºÅ")
        elif not server_state.is_logged_in and was_logged_in:
            logger.info("Ê£ÄÊµãÂà∞ÁÆ°ÁêÜÂëòÂ∑≤ÈÄÄÂá∫ÁôªÂΩï")
            
    except Exception as e:
        logger.error(f"Ê£ÄÊü•ÁôªÂΩïÁä∂ÊÄÅÂ§±Ë¥•: {e}")

async def notify_clients_cookies_updated():
    """ÈÄöÁü•ÊâÄÊúâÂÆ¢Êà∑Á´ØcookiesÂ∑≤Êõ¥Êñ∞"""
    try:
        connection_manager = app.state.connection_manager
        server_state = app.state.server_state
        
        message = json.dumps({
            "type": "cookies_updated",
            "timestamp": datetime.now().isoformat(),
            "count": len(server_state.global_cookies),
            "logged_in": server_state.is_logged_in
        })
        
        await connection_manager.broadcast(message)
        logger.info(f"Â∑≤ÈÄöÁü•ÊâÄÊúâÂÆ¢Êà∑Á´ØcookiesÊõ¥Êñ∞")
    except Exception as e:
        logger.error(f"ÈÄöÁü•ÂÆ¢Êà∑Á´ØcookiesÊõ¥Êñ∞Â§±Ë¥•: {e}")

async def extract_cookies_from_browser():
    """‰ªéÁÆ°ÁêÜÂëòÊµèËßàÂô®ÊèêÂèñÊúÄÊñ∞ÁöÑcookies - Èò≤Âç°Ê≠ªÁâàÊú¨"""
    try:
        server_state = app.state.server_state
        
        if not server_state.admin_context:
            logger.warning("ÁÆ°ÁêÜÂëòÊµèËßàÂô®‰∏ä‰∏ãÊñá‰∏çÂ≠òÂú®ÔºåÊó†Ê≥ïÊèêÂèñcookies")
            return
            
        logger.info("Ê≠£Âú®‰ªéÁÆ°ÁêÜÂëòÊµèËßàÂô®ÊèêÂèñÊúÄÊñ∞cookies...")
        
        # Ê∑ªÂä†Ë∂ÖÊó∂‰øùÊä§ÔºåÈò≤Ê≠¢Âç°Ê≠ª
        try:
            # ËÆæÁΩÆ5ÁßíË∂ÖÊó∂ÔºåÈò≤Ê≠¢ÊµèËßàÂô®ÂìçÂ∫îË∂ÖÊó∂ÂØºËá¥Âç°Ê≠ª
            browser_cookies = await asyncio.wait_for(
                server_state.admin_context.cookies(), 
                timeout=5.0
            )
            
            if browser_cookies:
                # Ê†áÂáÜÂåñcookiesÊ†ºÂºè
                standardized_cookies = []
                for cookie in browser_cookies:
                    if cookie.get('name') and cookie.get('value'):
                        standardized_cookie = {
                            'name': cookie['name'],
                            'value': cookie['value'],
                            'domain': cookie.get('domain', ''),
                            'path': cookie.get('path', '/'),
                            'secure': cookie.get('secure', False),
                            'httpOnly': cookie.get('httpOnly', False),
                            'sameSite': cookie.get('sameSite', 'Lax')
                        }
                        
                        if 'expires' in cookie and cookie['expires'] != -1:
                            standardized_cookie['expires'] = cookie['expires']
                        
                        standardized_cookies.append(standardized_cookie)
                
                # Êõ¥Êñ∞ÊúçÂä°Âô®cookies
                if standardized_cookies != server_state.global_cookies:
                    server_state.global_cookies = standardized_cookies
                    server_state.cookies_last_updated = datetime.now()
                    logger.info(f"‚úÖ ‰ªéÊµèËßàÂô®ÊèêÂèñÂπ∂Êõ¥Êñ∞‰∫Ü {len(standardized_cookies)} ‰∏™cookies")
                else:
                    logger.info("ÊµèËßàÂô®cookies‰∏éÊúçÂä°Âô®cookies‰∏ÄËá¥ÔºåÊó†ÈúÄÊõ¥Êñ∞")
                    
            else:
                logger.info("ÊµèËßàÂô®‰∏≠Ê≤°Êúâcookies")
                
        except asyncio.TimeoutError:
            logger.warning("‚ö†Ô∏è ÊµèËßàÂô®cookiesÊèêÂèñË∂ÖÊó∂(5Áßí)ÔºåË∑≥ËøáÊèêÂèñÊ≠•È™§")
            logger.info("üí° Â∞Ü‰ΩøÁî®ÊúçÂä°Âô®ÂÜÖÂ≠ò‰∏≠ÁöÑcookiesËøõË°å‰øùÂ≠ò")
            
    except Exception as e:
        logger.error(f"‰ªéÊµèËßàÂô®ÊèêÂèñcookiesÂ§±Ë¥•: {e}")
        logger.info("üí° Â∞Ü‰ΩøÁî®ÊúçÂä°Âô®ÂÜÖÂ≠ò‰∏≠ÁöÑcookiesËøõË°å‰øùÂ≠ò")


@app.on_event("startup")
async def startup_event():
    print("--> ÊúçÂä°Âô®ÂêØÂä®‰∏≠...")
    app.state.connection_manager = ConnectionManager()
    app.state.server_state = ServerState()
    app.state.access_coordinator = AccessCoordinator(
        connection_manager=app.state.connection_manager,
        server_state=app.state.server_state
    )
    
    print("--> Ê∏ÖÁêÜËÆøÈóÆÂçèË∞ÉÂô®Áä∂ÊÄÅ...")
    await app.state.access_coordinator.cleanup_stale_clients()
    
    print("--> ‰ªéÁ£ÅÁõòÂä†ËΩΩcookies...")
    await app.state.server_state.load_cookies_from_disk()
    
    print("--> ÂàùÂßãÂåñÁÆ°ÁêÜÂëòÊµèËßàÂô®...")
    app.state.admin_browser_task = asyncio.create_task(init_admin_browser())
    
    print("--> ÂêØÂä®ËÆøÈóÆÂçèË∞ÉÂô®ÁõëÊéß...")
    await app.state.access_coordinator.start_monitoring()
    
    print("--> ÊúçÂä°Âô®ÂêØÂä®ÂÆåÊàêÔºÅ")
    
    try:
        from server_api_extensions import init_server_manager, admin_router
        init_server_manager(app.state.server_state, app.state.access_coordinator, app.state.connection_manager)
        # Ê≥®ÂÜåÁÆ°ÁêÜAPIË∑ØÁî±
        app.include_router(admin_router)
        logger.info("APIÊâ©Â±ïÊ®°ÂùóÂ∑≤Âä†ËΩΩÔºåÁÆ°ÁêÜË∑ØÁî±Â∑≤Ê≥®ÂÜå")
    except ImportError:
        logger.warning("Êú™ÊâæÂà∞server_api_extensionsÊ®°ÂùóÔºåÈÉ®ÂàÜÁÆ°ÁêÜÂäüËÉΩ‰∏çÂèØÁî®")

@app.on_event("shutdown")
async def shutdown_event():
    print("--> ÊúçÂä°Âô®ÂÖ≥Èó≠‰∏≠...")
    
    try:
        # ÂÅúÊ≠¢ËÆøÈóÆÂçèË∞ÉÂô®ÁõëÊéß
        if app.state.access_coordinator:
            await app.state.access_coordinator.stop_monitoring()
        
        # Ê≠•È™§1: ‰ªéÊµèËßàÂô®ÊèêÂèñÊúÄÊñ∞cookies (Â∏¶Ë∂ÖÊó∂‰øùÊä§)
        print("üì• Ê≠•È™§1: ‰ªéÁÆ°ÁêÜÂëòÊµèËßàÂô®ÊèêÂèñÊúÄÊñ∞cookies...")
        try:
            await asyncio.wait_for(extract_cookies_from_browser(), timeout=8.0)
        except asyncio.TimeoutError:
            logger.warning("‚ö†Ô∏è cookiesÊèêÂèñÊ≠•È™§Ë∂ÖÊó∂ÔºåÁªßÁª≠ÊâßË°åÂêéÁª≠Ê≠•È™§")
        
        # Ê≠•È™§2: ‰øùÂ≠òcookiesÂà∞Á£ÅÁõò (Â∏¶Ë∂ÖÊó∂‰øùÊä§)
        print("üíæ Ê≠•È™§2: ‰øùÂ≠òcookiesÂà∞Á£ÅÁõò...")
        try:
            await asyncio.wait_for(app.state.server_state.save_cookies_to_disk(), timeout=3.0)
        except asyncio.TimeoutError:
            logger.warning("‚ö†Ô∏è cookies‰øùÂ≠òË∂ÖÊó∂Ôºå‰ΩÜÂèØËÉΩÂ∑≤ÈÉ®ÂàÜÂÆåÊàê")
        
        # Ê≠•È™§3: ÂÖ≥Èó≠ÊµèËßàÂô® (Â∏¶Ë∂ÖÊó∂‰øùÊä§)
        print("üåê Ê≠•È™§3: ÂÖ≥Èó≠ÁÆ°ÁêÜÂëòÊµèËßàÂô®...")
        try:
            if app.state.server_state.admin_browser:
                await asyncio.wait_for(app.state.server_state.admin_browser.close(), timeout=5.0)
            if app.state.server_state.playwright:
                await asyncio.wait_for(app.state.server_state.playwright.stop(), timeout=3.0)
        except asyncio.TimeoutError:
            logger.warning("‚ö†Ô∏è ÊµèËßàÂô®ÂÖ≥Èó≠Ë∂ÖÊó∂ÔºåÂº∫Âà∂ÁªàÊ≠¢")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÊµèËßàÂô®ÂÖ≥Èó≠Êó∂Âá∫Èîô: {e}")
        
        # ÂèñÊ∂àÂêéÂè∞‰ªªÂä°
        if hasattr(app.state, 'admin_browser_task') and app.state.admin_browser_task:
            app.state.admin_browser_task.cancel()
        if hasattr(app.state, 'cookie_update_task') and app.state.cookie_update_task:
            app.state.cookie_update_task.cancel()
            
    except Exception as e:
        logger.error(f"ÊúçÂä°Âô®ÂÖ≥Èó≠ËøáÁ®ã‰∏≠Âá∫Èîô: {e}")
    
    print("--> ÊúçÂä°Âô®Â∑≤ÂÖ≥Èó≠")

# --- API Endpoints ---
@app.post("/create_session")
async def create_session(request: Request):
    session_id = str(uuid.uuid4())
    request.app.state.server_state.sessions[session_id] = {"created_at": datetime.now()}
    return {"session_id": session_id}

@app.post("/access/request")
async def request_access_endpoint(request: Request):
    data = await request.json()
    session_id = data.get("session_id")
    if not session_id:
        raise HTTPException(status_code=400, detail="Áº∫Â∞ësession_id")
    result = await request.app.state.access_coordinator.request_access(
        client_id=session_id,
        priority=data.get("priority", 0),
        requested_domains=data.get("domains")
    )
    result['session_id'] = session_id
    return JSONResponse(content=result)

@app.get("/domains")
async def get_domains_info(request: Request):
    """Ëé∑ÂèñÂüüÂêçËØ¶ÁªÜ‰ø°ÊÅØÂàóË°®"""
    server_state = request.app.state.server_state
    access_coordinator = request.app.state.access_coordinator
    
    domains_info = []
    
    # Ëé∑ÂèñÊØè‰∏™ÂüüÂêçÁöÑcookiesÊï∞Èáè
    cookies_by_domain = {}
    for cookie in server_state.global_cookies:
        domain = cookie.get('domain', '').lstrip('.')
        if domain:
            cookies_by_domain[domain] = cookies_by_domain.get(domain, 0) + 1
    
    # ÊûÑÂª∫ÂüüÂêç‰ø°ÊÅØÂàóË°®
    for domain in server_state.available_domains:
        # Ê£ÄÊü•ÂüüÂêçÊòØÂê¶Ë¢´ÂàÜÈÖç
        allocated_to = []
        available = True
        
        async with access_coordinator.access_lock:
            for client_id, client_domains in access_coordinator.active_clients.items():
                if domain in client_domains:
                    allocated_to.append(client_id)
                    available = False
        
        domain_info = {
            "domain": domain,
            "cookie_count": cookies_by_domain.get(domain, 0),
            "available": available,
            "allocated_to": allocated_to
        }
        domains_info.append(domain_info)
    
    return {"domains": domains_info}

@app.get("/health")
async def health_check():
    return {"status": "ok", "timestamp": datetime.now().isoformat()}

@app.get("/cookies")
async def get_cookies(request: Request):
    """Ëé∑ÂèñÂΩìÂâçcookies‰ø°ÊÅØ"""
    server_state = request.app.state.server_state
    return {
        "success": True,
        "cookies": server_state.global_cookies,
        "logged_in": server_state.is_logged_in,
        "last_updated": server_state.cookies_last_updated.isoformat() if server_state.cookies_last_updated else None,
        "count": len(server_state.global_cookies)
    }

@app.get("/access/status")
async def get_access_status(request: Request):
    """Ëé∑ÂèñËÆøÈóÆÁä∂ÊÄÅ‰ø°ÊÅØ"""
    coordinator = request.app.state.access_coordinator
    
    async with coordinator.access_lock:
        active_client = None
        if coordinator.active_clients:
            # Ëé∑ÂèñÁ¨¨‰∏Ä‰∏™Ê¥ªË∑ÉÂÆ¢Êà∑Á´Ø
            active_client = list(coordinator.active_clients.keys())[0]
        
        queue_details = []
        for i, item in enumerate(coordinator.waiting_queue):
            queue_details.append({
                "position": i + 1,
                "client_id": item["client_id"],
                "priority": item["priority"],
                "request_time": item["request_time"].isoformat(),
                "requested_domains": item.get("requested_domains", [])
            })
        
        return {
            "active_client": active_client,
            "active_count": len(coordinator.active_clients),
            "max_concurrent": coordinator.max_concurrent_clients,
            "queue_length": len(coordinator.waiting_queue),
            "queue_details": queue_details,
            "timestamp": datetime.now().isoformat()
        }

@app.post("/access/release/{session_id}")
async def release_access_endpoint(session_id: str, request: Request):
    """ÈáäÊîæËÆøÈóÆÊùÉÈôê"""
    result = await request.app.state.access_coordinator.release_access(session_id, "manual_release")
    return JSONResponse(content=result)

@app.post("/cookies/domains")
async def get_cookies_for_domains(request: Request):
    """Ëé∑ÂèñÊåáÂÆöÂüüÂêçÁöÑcookies"""
    try:
        data = await request.json()
        session_id = data.get("session_id")
        requested_domains = data.get("domains", [])
        
        if not session_id:
            raise HTTPException(status_code=400, detail="Áº∫Â∞ësession_id")
        
        if not requested_domains:
            raise HTTPException(status_code=400, detail="Áº∫Â∞ëdomains")
        
        server_state = request.app.state.server_state
        access_coordinator = request.app.state.access_coordinator
        
        # È™åËØÅÂÆ¢Êà∑Á´ØÊòØÂê¶ÊúâÊùÉÈôêËÆøÈóÆËøô‰∫õÂüüÂêç
        async with access_coordinator.access_lock:
            if session_id not in access_coordinator.active_clients:
                raise HTTPException(status_code=403, detail="Êó†ËÆøÈóÆÊùÉÈôê")
            
            client_info = access_coordinator.active_clients[session_id]
            allocated_domains = client_info.get("allocated_domains", [])
            unauthorized_domains = [d for d in requested_domains if d not in allocated_domains]
            
            if unauthorized_domains:
                raise HTTPException(
                    status_code=403, 
                    detail=f"Êó†ÊùÉÈôêËÆøÈóÆÂüüÂêç: {unauthorized_domains}"
                )
        
        # ËøáÊª§ÊåáÂÆöÂüüÂêçÁöÑcookies
        domain_cookies = []
        for cookie in server_state.global_cookies:
            cookie_domain = cookie.get('domain', '').lstrip('.')
            if cookie_domain in requested_domains:
                domain_cookies.append(cookie)
        
        return {
            "success": True,
            "cookies": domain_cookies,
            "domains": requested_domains,
            "count": len(domain_cookies)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ëé∑ÂèñcookiesÂ§±Ë¥•: {str(e)}")

@app.get("/admin/key")
async def get_admin_key(request: Request):
    """Ëé∑ÂèñÁÆ°ÁêÜÂëòÂØÜÈí•"""
    server_state = request.app.state.server_state
    return {"admin_key": server_state.admin_key}

@app.post("/admin/cookies")
async def update_cookies(
    request: Request,
    x_admin_key: str = Header(..., description="ÁÆ°ÁêÜÂëòÂØÜÈí•")
):
    """ÁÆ°ÁêÜÂëòÊâãÂä®Êõ¥Êñ∞cookies"""
    server_state = request.app.state.server_state
    
    # È™åËØÅÁÆ°ÁêÜÂëòÂØÜÈí•
    if not server_state.verify_admin_key(x_admin_key):
        raise HTTPException(status_code=401, detail="Êó†ÊïàÁöÑÁÆ°ÁêÜÂëòÂØÜÈí•")
    
    try:
        data = await request.json()
        
        # Êô∫ËÉΩÂêàÂπ∂cookies
        if 'cookies' in data:
            old_count = len(server_state.global_cookies)
            new_cookies = data['cookies']
            
            # Ê£ÄÊü•ÊòØÂê¶‰∏∫Âº∫Âà∂Ë¶ÜÁõñÊ®°Âºè
            force_replace = data.get('force_replace', False)
            
            if force_replace:
                # Âº∫Âà∂Ë¶ÜÁõñÊ®°ÂºèÔºöÁõ¥Êé•ÊõøÊç¢ÊâÄÊúâcookies
                server_state.global_cookies = new_cookies
                logger.info(f"üîß ÁÆ°ÁêÜÂëòÂº∫Âà∂Ë¶ÜÁõñcookies: {old_count} ‚Üí {len(new_cookies)} ‰∏™")
                final_count = len(new_cookies)
                action_msg = f"Â∑≤Âº∫Âà∂Ë¶ÜÁõñ‰∏∫ {final_count} ‰∏™cookies"
            else:
                # Êô∫ËÉΩÂêàÂπ∂Ê®°ÂºèÔºöÂú®ÂéüÂü∫Á°Ä‰∏äÂ¢ûÂä†Êñ∞cookies
                existing_cookies = server_state.global_cookies.copy()
                cookie_keys = set()  # Áî®‰∫éÂéªÈáçÁöÑkeyÈõÜÂêà
                merged_cookies = []
                
                # È¶ñÂÖàÊ∑ªÂä†Êñ∞ÁöÑcookiesÔºà‰ºòÂÖàÁ∫ßÊõ¥È´òÔºâ
                for cookie in new_cookies:
                    cookie_key = f"{cookie.get('name', '')}_{cookie.get('domain', '')}"
                    if cookie_key not in cookie_keys:
                        merged_cookies.append(cookie)
                        cookie_keys.add(cookie_key)
                
                # ÁÑ∂ÂêéÊ∑ªÂä†‰∏çÂÜ≤Á™ÅÁöÑÂéüÊúâcookies
                for cookie in existing_cookies:
                    cookie_key = f"{cookie.get('name', '')}_{cookie.get('domain', '')}"
                    if cookie_key not in cookie_keys:
                        merged_cookies.append(cookie)
                        cookie_keys.add(cookie_key)
                
                server_state.global_cookies = merged_cookies
                final_count = len(merged_cookies)
                logger.info(f"üîß ÁÆ°ÁêÜÂëòÊô∫ËÉΩÂêàÂπ∂cookies: ÂéüÊúâ{old_count}‰∏™ + Êñ∞Â¢û{len(new_cookies)}‰∏™ = ÂêàÂπ∂Âêé{final_count}‰∏™")
                action_msg = f"Â∑≤Êô∫ËÉΩÂêàÂπ∂ÔºåÊñ∞Â¢û {len(new_cookies)} ‰∏™ÔºåÊÄªËÆ° {final_count} ‰∏™cookies"
            
            server_state.cookies_last_updated = datetime.now()
            
            # Êõ¥Êñ∞ÁôªÂΩïÁä∂ÊÄÅ
            if 'logged_in' in data:
                server_state.is_logged_in = data['logged_in']
            else:
                await check_login_status()
            
            # Êõ¥Êñ∞ÂèØÁî®ÂüüÂêç
            server_state.update_available_domains()
            
            # ‰øùÂ≠òÂà∞Á£ÅÁõò
            await server_state.save_cookies_to_disk()
            
            # ÈÄöÁü•ÂÆ¢Êà∑Á´Ø
            await notify_clients_cookies_updated()
            
            return {
                "success": True,
                "message": action_msg,
                "old_count": old_count,
                "new_count": final_count,
                "new_cookies_added": len(new_cookies) if not force_replace else final_count,
                "mode": "force_replace" if force_replace else "smart_merge",
                "logged_in": server_state.is_logged_in,
                "available_domains": len(server_state.available_domains)
            }
        else:
            raise HTTPException(status_code=400, detail="Áº∫Â∞ëcookiesÊï∞ÊçÆ")
            
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Êó†ÊïàÁöÑJSONÊï∞ÊçÆ")
    except Exception as e:
        logger.error(f"ÁÆ°ÁêÜÂëòÊõ¥Êñ∞cookiesÂ§±Ë¥•: {e}")
        raise HTTPException(status_code=500, detail=f"Êõ¥Êñ∞Â§±Ë¥•: {str(e)}")

@app.post("/admin/navigate")
async def admin_navigate(
    request: Request,
    x_admin_key: str = Header(..., description="ÁÆ°ÁêÜÂëòÂØÜÈí•")
):
    """ÁÆ°ÁêÜÂëòÊµèËßàÂô®ÂØºËà™"""
    server_state = request.app.state.server_state
    
    # È™åËØÅÁÆ°ÁêÜÂëòÂØÜÈí•
    if not server_state.verify_admin_key(x_admin_key):
        raise HTTPException(status_code=401, detail="Êó†ÊïàÁöÑÁÆ°ÁêÜÂëòÂØÜÈí•")
    
    try:
        data = await request.json()
        url = data.get('url')
        
        if not url:
            raise HTTPException(status_code=400, detail="Áº∫Â∞ëURLÂèÇÊï∞")
        
        if not server_state.admin_page:
            raise HTTPException(status_code=503, detail="ÁÆ°ÁêÜÂëòÊµèËßàÂô®Êú™ÂàùÂßãÂåñ")
        
        # ÂØºËà™Âà∞ÊåáÂÆöURL
        await server_state.admin_page.goto(url)
        
        logger.info(f"üåê ÁÆ°ÁêÜÂëòÊµèËßàÂô®ÂØºËà™Âà∞: {url}")
        
        return {
            "success": True,
            "message": f"Â∑≤ÂØºËà™Âà∞: {url}",
            "current_url": server_state.admin_page.url
        }
        
    except Exception as e:
        logger.error(f"ÁÆ°ÁêÜÂëòÊµèËßàÂô®ÂØºËà™Â§±Ë¥•: {e}")
        raise HTTPException(status_code=500, detail=f"ÂØºËà™Â§±Ë¥•: {str(e)}")
    
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.app.state.connection_manager.connect(websocket, session_id)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        websocket.app.state.connection_manager.disconnect(session_id)
        await websocket.app.state.access_coordinator.release_access(session_id, "disconnected")

def main():
    print("\n=== Remote Browser Server ===")
    print("ÁõëÂê¨Âú∞ÂùÄ: 0.0.0.0")
    print("ÁõëÂê¨Á´ØÂè£: 8001")
    print("=====================================\n")
    uvicorn.run(app, host="0.0.0.0", port=8001, log_level="info")

if __name__ == "__main__":
    main()
